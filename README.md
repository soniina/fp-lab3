# Лабораторная работа №3

### **Павличенко Софья P3315**

## Задание

В рамках лабораторной работы вам предлагается повторно реализовать лабораторную работу по предмету "Вычислительная математика" посвящённую интерполяции (в разные годы это лабораторная работа 3 или 4) со следующими дополнениями:

- обязательно должна быть реализована линейная интерполяция (отрезками, link);
- настройки алгоритма интерполяции и выводимых данных должны задаваться через аргументы командной строки:
    - какие алгоритмы использовать (в том числе два сразу);
    - частота дискретизации результирующих данных;
    - и т.п.;
- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру x;y\n или x\ty\n) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;
- выходные данные должны подаваться на стандартный вывод;
- программа должна работать в потоковом режиме (пример -- cat | grep 11), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

Приложение должно быть организовано следующим образом:
```
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +-----------------------+      +------------------------------+
    | алгоритм интерполяции |<-----| генератор точек, для которых |
    +-----------------------+      | необходимо вычислить         |
            |                      | промежуточные значения       |
            |                      +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

Потоковый режим для алгоритмов, работающих с группой точек должен работать следующим образом:
```
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```
где:

- каждая строка -- окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые -- добавляются);
- o -- рассчитанные данные, можно видеть:
    - большинство окон используется для расчёта всего одной точки, так как именно в "центре" результат наиболее точен;
    - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет.
- . -- точки, задействованные в рассчете значения o.
- x -- точки, расчёт которых для "окон" не требуется.

## Реализация

Программа архитектурно разделена на три модуля:

### `Interpolation.hs`
Модуль содержит функции, реализующие вычислительную логику.<br>
Для интерполяция Ньютона алгоритм вычисляет разделенные разности для переданного набора точек. Эти значения используются в качестве коэффициентов при построении интерполяционного полинома. <br>
Для линейной интерполяции функция принимает на вход целое окно данных, но для расчета использует только две точки. Алгоритм просматривает список пар соседних точек и находит именно ту пару, между которыми лежит искомая координата. После этого применяется формула линейной интерполяции для найденного отрезка.

```haskell
linearSpline :: [Point] -> Double -> Double
linearSpline points x =
  let intervals = zip points (tail points)
      match (_, (x2, _)) = x <= x2
      validIntervals = dropWhile (not . match) intervals

      (pLeft, pRight) =
        if null validIntervals
          then last intervals
          else head validIntervals
   in linear pLeft pRight x

newton :: [Point] -> Double -> Double
newton points x =
  let coeffs = [dividedDifference (take k points) | k <- [1 .. length points]]

      xs = map fst points
      terms = scanl (*) 1.0 [x - xi | xi <- init xs]
   in sum $ zipWith (*) coeffs terms
```

### `StreamProcessor.hs`
Модуль отвечает за управление состоянием скользящего окна. Функция processStream принимает конфигурацию и список входных точек, возвращая список результатов. Внутри реализована рекурсия, проходящая через фазы: накопление буфера, обработка первого окна, циклический сдвиг окна при получении новых данных и обработка остатка данных после EOF. Благодаря ленивости Haskell, элементы входного списка обрабатываются по одному по мере необходимости.
```haskell
processStream :: Config -> [Point] -> [ResultPoint]
processStream config = accumulate []
  where
    mid = windowSize config `div` 2

    accumulate :: [Point] -> [Point] -> [ResultPoint]
    accumulate _ [] = []
    accumulate buffer (p : ps)
      | length buffer < windowSize config - 1 = accumulate (buffer ++ [p]) ps
      | otherwise = stepStart config (buffer ++ [p]) ps

    stepStart :: Config -> [Point] -> [Point] -> [ResultPoint]
    stepStart cfg window restInput =
      let pStart = head window
          pMid = window !! mid

          xs = generatePoints (fst pStart) (fst pMid) (stepSize cfg)

          startPoints = calculatePoints cfg window xs
       in startPoints ++ stepLoop cfg window restInput

    stepLoop :: Config -> [Point] -> [Point] -> [ResultPoint]
    stepLoop cfg buffer [] = stepFinal cfg buffer
    stepLoop cfg buffer (nextP : rest) =
      let newBuffer = tail buffer ++ [nextP]
          pPreMid = newBuffer !! (mid - 1)
          pMid = newBuffer !! mid

          xs = generatePoints (fst pPreMid) (fst pMid) (stepSize cfg)
          loopPoints = calculatePoints cfg newBuffer xs
       in loopPoints ++ stepLoop cfg newBuffer rest

    stepFinal :: Config -> [Point] -> [ResultPoint]
    stepFinal cfg buffer =
      let pMid = buffer !! mid
          pEnd = last buffer

          xs = generatePoints (fst pMid) (fst pEnd + stepSize cfg / 2) (stepSize cfg)
       in calculatePoints cfg buffer xs
```

### `Main.hs`
Точка входа в программу. Здесь происходит разбор аргументов командной строки и взаимодействие с внешним миром через монаду IO. Чтение данных осуществляется функцией getContents, которая создает ленивый поток символов из stdin. Этот поток разбивается на строки, парсится в структуры данных и передается в processStream. Результаты вычислений выводятся в stdout построчно.

```haskell
main :: IO ()
main = do
  args <- getArgs

  let config = parseArgs args defaultConfig

  content <- getContents
  let inputLines = lines content
  let points = map parseLine (filter (not . null) inputLines)

  let results = processStream config points

  mapM_ (putStrLn . formatResult) results
```

## Ввод-вывод программы
```
< stack run -- --both --n 4 --step 0.5`
< 0 0
< 1 1 
< 2 4
< 3 9
> linear: 0.0 0.0
> newton: 0.0 0.0
> linear: 0.5 0.5
> newton: 0.5 0.25
> linear: 1.0 1.0
> newton: 1.0 1.0
> linear: 1.5 2.5
> newton: 1.5 2.25
< 4 16
> linear: 2.0 4.0
> newton: 2.0 4.0
> linear: 2.5 6.5
> newton: 2.5 6.25
< 5 25
> linear: 3.0 9.0
> newton: 3.0 9.0
> linear: 3.5 12.5
> newton: 3.5 12.25
```


## Выводы

В ходе лабораторной работы были реализованы алгоритмы интерполяции в функциональном стиле. Использование механизма ленивых вычислений позволило организовать потоковую обработку данных естественным образом: вместо императивных циклов чтения используется работа с ленивым списком, элементы которого вычисляются только по мере запроса на вывод.<br>
Разделение программы на чистые функции (ядро логики и математика) и ввод-вывод (монада IO в Main) обеспечило модульность кода и предсказуемость работы алгоритмов. Также стандартные функции работы со списками в Haskell оказались удобным инструментом для прямой трансляции математических формул (таких как полином Ньютона) в программный код.
